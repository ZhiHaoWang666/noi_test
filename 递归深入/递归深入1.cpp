/*
递归就是函数自身调用自身
数列形递归：项与项之间存在一些关联性 我们就可以使用递归
一个函数既然可以求出数列的第	N项，那么我们就可以使用这个函数
求出n-1项或者n+1项
一般的起始项是一已知的

求解的过程：
1:找出项与项之间的规律
2：函数自身调用自身
3：交代起始项，设置递归出口

递归的重要思想：
1.一个函数既然可以求出数列的第N项，那么我们就可以使用这个函数
求出n-1 项或者 n+1项
2.一个函数既然可以解决问题的第N步，那么我们可以使用这个函数解决问题
的第n-1步或者n+1步

首项为1 公差为2的等差数列

*/
//复习递归
//层层递归 层层返回
/*
code :

int func(int 1){
	int ans;
	if(n == 1){
		ans = 1;
	}else{
		ans = func(n-1)+2;
	}
	return ans;
}


值传递 地址传递
1：每个函数去运行的时候都会生成一个独立的内存，来存储我们在函数内部定义的变量，
因此函数之间互相看不到对方定义的变量名，因此不会出现变量名冲突的问题

值传递. 2：向函数中传递整数，本质是将整数的值拷贝了一份传递给函数，向函数传递数组的时候，
本质是将数组的地址传递给了函数

地址传递. 3

递归深入：将循环改为递归
递归存在的问题：
1：效率低 层层递归层层返回 相当于执行了两次循环
2：更加消耗内存：每个函数去运行的时候都会生成一个独立的内存 以此类推，内存占用会越来越高

例子：编程求解：1+2+3+........N
1：公共变量：所有的函数都能访问到公共变量，并且都能修改公共变量

通过层层累加，层层返回求和

*/

#include<iostream>
using namespace std;
//例子求解

int s;
void func(int i){
	if(i != 1){
		if(i%2 == 0){
			i /= 2;
		}else{
			i = i*3+1;
		}
		s++;
	}
	else{
		return;
	}
	func(i);
}

int main(){
	// int n;
	// int res = 0;
	// cin >> n;
	// while(n != 1){
	// 	if(n%2 == 0){
	// 		n/=2;
	// 	}else{
	// 		n = n*3+1;
	// 	}
	// 	res ++;
	// }
	// cout << res;
	int n;
	cin >> n;
	func(n);
	cout << s;
	return 0;
}